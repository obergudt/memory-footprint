// Generated by CoffeeScript 1.10.0
(function() {
  var ProgressBar, argv, bar, c, checkMod, contents, e, error, finalStats, fs, index, key, loadedMods, measureCount, measureInterval, mods, path, relevantDir, relevantFile, results, runCount, runDelay, runs;

  argv = require("minimist")(process.argv.slice(2));

  ProgressBar = require('progress');

  fs = require("fs");

  path = require("path");

  try {
    relevantFile = argv.file || (argv["_"].length === 1 ? argv["_"][0] : './package.json');
    relevantDir = path.dirname(relevantFile);
    contents = fs.readFileSync(relevantFile, 'utf8');
    c = JSON.parse(contents);
    mods = [];
    for (key in c.dependencies) {
      mods.push(key);
    }
  } catch (error) {
    e = error;
    console.log("Could not read Modules from file " + argv.file);
    process.exit(1);
  }

  finalStats = [];

  loadedMods = [];

  results = [];

  index = 0;

  runs = 0;

  measureInterval = parseInt(argv.interval, 10) || 25;

  measureCount = parseInt(argv.times, 10) || 5;

  runCount = parseInt(argv.runs, 10) || 2;

  runDelay = parseInt(argv.delay, 10) || 1000;

  bar = new ProgressBar(':bar :percent (:etas left)', {
    total: mods.length * runCount
  });

  console.log("================\nMemory Footprint\n================\n\nTesting " + mods.length + " modules.\nMeasuring every " + measureInterval + "ms, " + measureCount + " times.\nRunning " + runCount + " times with a " + runDelay + "ms delay.");

  checkMod = function(index) {
    var _, aggregate, error1, i, initial, interval, item, j, k, len, len1, len2, m, measurePoints, moduleMeasureCount, ref, result, resultItem, stats, value;
    if (index >= mods.length) {
      stats = finalStats.sort(function(a, b) {
        if (a.size > b.size) {
          return -1;
        } else if (a.size < b.size) {
          return 1;
        } else {
          return 0;
        }
      });
      results.push(stats);
      if (runs < runCount - 1) {
        _ = require("underscore");
        runs++;
        index = 0;
        loadedMods = [];
        finalStats = [];
        _.each(_.keys(require.cache), function(key) {
          return delete require.cache[key];
        });
        return setTimeout(function() {
          return checkMod(index);
        }, runDelay);
      } else {
        console.log("\n");
        aggregate = {};
        ref = results[0];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          aggregate[item.name] = [];
          for (j = 0, len1 = results.length; j < len1; j++) {
            result = results[j];
            for (k = 0, len2 = result.length; k < len2; k++) {
              resultItem = result[k];
              if (resultItem.name === item.name) {
                aggregate[item.name].push(resultItem.size);
              }
            }
          }
        }
        for (key in aggregate) {
          value = aggregate[key];
          value = (1 / value.length) * value.reduce(function(p, c) {
            return p + c;
          });
          console.log(key, ":", require("filesize")(value));
        }
        return process.exit(0);
      }
    } else {
      moduleMeasureCount = measureCount;
      measurePoints = [];
      try {
        initial = process.memoryUsage();
        m = require(path.join(relevantDir, "node_modules", mods[index]));
        loadedMods.push(m);
      } catch (error1) {
        e = error1;
        bar.tick();
        checkMod(++index);
        return;
      }
      return interval = setInterval(function() {
        var loaded, size;
        loaded = process.memoryUsage();
        measurePoints.push(loaded.rss - initial.rss);
        moduleMeasureCount--;
        initial = loaded;
        if (moduleMeasureCount === 0) {
          size = measurePoints.reduce(function(previousValue, currentValue) {
            return previousValue + currentValue;
          });
          finalStats.push({
            name: mods[index],
            size: size
          });
          bar.tick();
          checkMod(++index);
          return clearInterval(interval);
        }
      }, measureInterval);
    }
  };

  checkMod(index);

}).call(this);
