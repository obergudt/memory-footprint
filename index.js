// Generated by CoffeeScript 1.10.0
(function() {
  var ProgressBar, _, argv, bar, c, calculationStrategy, checkMod, contents, e, error, finalStats, fs, index, key, loadedMods, measureCount, measureInterval, mods, oldConsoleLog, path, relevantDir, relevantFile, results, runCount, runDelay, runs;

  argv = require("minimist")(process.argv.slice(2));

  ProgressBar = require('progress');

  fs = require("fs");

  path = require("path");

  _ = require("underscore");

  if (!(typeof global !== "undefined" && global !== null ? global.gc : void 0)) {
    console.log("Please start this program with node --expose-gc to allow manual garbage collection");
    exit(2);
  }

  try {
    relevantFile = argv.f || argv.file || (argv["_"].length === 1 ? argv["_"][0] : './package.json');
    relevantDir = path.dirname(relevantFile);
    contents = fs.readFileSync(relevantFile, 'utf8');
    c = JSON.parse(contents);
    mods = [];
    for (key in c.dependencies) {
      mods.push(key);
    }
  } catch (error) {
    e = error;
    console.log("Could not read Modules from file " + argv.file);
    process.exit(1);
  }

  finalStats = [];

  loadedMods = [];

  results = [];

  index = 0;

  runs = 0;

  measureInterval = parseInt(argv.i, 10) || parseInt(argv.interval, 10) || 25;

  measureCount = parseInt(argv.t, 10) || parseInt(argv.times, 10) || 5;

  runCount = parseInt(argv.r, 10) || parseInt(argv.runs, 10) || 2;

  runDelay = parseInt(argv.d, 10) || parseInt(argv.delay, 10) || 1000;

  calculationStrategy = argv.s || argv.strategy || "max";

  bar = new ProgressBar(':bar :percent (:etas left)', {
    total: mods.length * runCount
  });

  if (calculationStrategy !== "max") {
    calculationStrategy = 'max';
  }

  console.log("================\nMemory Footprint\n================\n\nTesting " + mods.length + " modules.\nMeasuring every " + measureInterval + "ms, " + measureCount + " times.\nRunning " + runCount + " times with a " + runDelay + "ms delay.");

  oldConsoleLog = console.log;

  console.log = console.warn = console.error = function() {};

  checkMod = function(index) {
    var aggregate, error1, i, initial, interval, item, j, k, l, len, len1, len2, len3, m, measurePoints, moduleMeasureCount, ref, result, resultItem, sorted, stats, value;
    if (index >= mods.length) {
      stats = finalStats.sort(function(a, b) {
        if (a.size > b.size) {
          return -1;
        } else if (a.size < b.size) {
          return 1;
        } else {
          return 0;
        }
      });
      stats = finalStats;
      results.push(stats);
      if (runs < runCount - 1) {
        _ = require("underscore");
        runs++;
        index = 0;
        loadedMods = [];
        finalStats = [];
        _.each(_.keys(require.cache), function(key) {
          return delete require.cache[key];
        });
        mods = _.shuffle(mods);
        if (typeof global !== "undefined" && global !== null) {
          if (typeof global.gc === "function") {
            global.gc();
          }
        }
        return setTimeout(function() {
          return checkMod(index);
        }, runDelay);
      } else {
        aggregate = {};
        sorted = [];
        ref = results[0];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          aggregate[item.name] = [];
          for (j = 0, len1 = results.length; j < len1; j++) {
            result = results[j];
            for (k = 0, len2 = result.length; k < len2; k++) {
              resultItem = result[k];
              if (resultItem.name === item.name) {
                aggregate[item.name].push(resultItem.size);
              }
            }
          }
        }
        for (key in aggregate) {
          value = aggregate[key];
          if (calculationStrategy === 'max') {
            value = _.max(value);
          } else {
            value = (1 / value.length) * value.reduce(function(p, c) {
              if (p >= 0 && c > 0) {
                return p + c;
              } else {
                return p;
              }
            }, 0);
          }
          sorted.push({
            name: key,
            size: value
          });
        }
        sorted = sorted.sort(function(a, b) {
          if (a.size > b.size) {
            return -1;
          } else if (a.size < b.size) {
            return 1;
          } else {
            return 0;
          }
        });
        console.log = oldConsoleLog;
        for (l = 0, len3 = sorted.length; l < len3; l++) {
          item = sorted[l];
          console.log(item.name, ":", require("filesize")(item.size || 0));
        }
        return process.exit(0);
      }
    } else {
      moduleMeasureCount = measureCount;
      measurePoints = [];
      try {
        global.gc();
        initial = process.memoryUsage();
        m = require(path.join(relevantDir, "node_modules", mods[index]));
        loadedMods.push(m);
      } catch (error1) {
        e = error1;
        global.gc();
        bar.tick();
        checkMod(++index);
        return;
      }
      return interval = setInterval(function() {
        var loaded, size;
        loaded = process.memoryUsage();
        measurePoints.push(loaded.rss - initial.rss);
        moduleMeasureCount--;
        initial = loaded;
        if (moduleMeasureCount === 0) {
          size = measurePoints.reduce(function(previousValue, currentValue) {
            if (previousValue >= 0 && currentValue > 0) {
              return previousValue + currentValue;
            } else {
              return previousValue;
            }
          }, 0);
          finalStats.push({
            name: mods[index],
            size: size
          });
          bar.tick();
          checkMod(++index);
          return clearInterval(interval);
        }
      }, measureInterval);
    }
  };

  global.gc();

  mods = _.shuffle(mods);

  checkMod(index);

}).call(this);
